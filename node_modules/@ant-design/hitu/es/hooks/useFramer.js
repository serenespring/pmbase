var _excluded = ["frames"];

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

import * as React from 'react';
import { fillInfo, getTransitionValue } from '../utils/svgUtil';
export default function useFramer(totalFrames, config) {
  // const { defaultPlay, frameRate = 60, onPlay, onFrame, loop } = config || {};
  var configRef = React.useRef(config || {});
  configRef.current = config || {};

  var _React$useState = React.useState({}),
      _React$useState2 = _slicedToArray(_React$useState, 2),
      forceUpdate = _React$useState2[1];

  var frameRef = React.useRef(configRef.current.defaultFrame || 0);
  var frameIdRef = React.useRef(null);
  var triggerRef = React.useRef(false);
  var timestampRef = React.useRef(Date.now());
  var timesDiffRef = React.useRef(0);
  var initRef = React.useRef(false); // Frame

  function getFrameDuration() {
    return Math.floor(1000 / (configRef.current.frameRate || 60));
  }

  var triggerMotion;

  function setFrame(frame) {
    if (frameRef.current !== frame) {
      frameRef.current = frame;
      forceUpdate({});
    }
  }

  function cancelMotion() {
    triggerRef.current = false;
    window.cancelAnimationFrame(frameIdRef.current);
  }

  function nextFrame(manual) {
    if (!totalFrames || !triggerRef.current) {
      cancelMotion();
      return;
    }

    frameIdRef.current = window.requestAnimationFrame(function () {
      var frameDuration = getFrameDuration();
      var now = Date.now();
      var timestampDiff = now - timestampRef.current + timesDiffRef.current;
      var frameDiff = Math.floor(timestampDiff / frameDuration);
      var targetFrame = frameRef.current + frameDiff;

      if (targetFrame >= totalFrames) {
        if (configRef.current.loop !== false || manual) {
          targetFrame = 0;
        } else {
          targetFrame = totalFrames - 1;
          triggerMotion(false);
        }
      }
      /**
       * Loop to trigger `onFrame`.
       * This should trigger each event by each frame even if not displayed
       */


      if (frameRef.current !== targetFrame && configRef.current.onFrame) {
        var startFrame = frameRef.current;
        var endFrame = targetFrame;

        if (targetFrame === 0) {
          endFrame = totalFrames - 1;
        }

        for (var frame = startFrame + 1; frame <= endFrame; frame += 1) {
          configRef.current.onFrame(frame);
        } // Trigger missing frame: 0


        if (targetFrame === 0) {
          configRef.current.onFrame(0);
        }
      }

      setFrame(targetFrame);
      timesDiffRef.current = timestampDiff % frameDuration;
      timestampRef.current = now;
      nextFrame(false);
    });
  }

  triggerMotion = function triggerMotion(start) {
    var mergedStart = start !== undefined ? start : !triggerRef.current;

    if (triggerRef.current === mergedStart) {
      return;
    }

    triggerRef.current = mergedStart;

    if (mergedStart) {
      timestampRef.current = Date.now();
      timesDiffRef.current = 0;

      if (frameRef.current >= totalFrames - 1) {
        frameRef.current = 0;
      }

      nextFrame(true);
    } else {
      cancelMotion();
    }

    if (configRef.current.onPlay) {
      configRef.current.onPlay(mergedStart);
    }

    forceUpdate({});
  };

  function getFrameInfo(_ref) {
    var frames = _ref.frames,
        rest = _objectWithoutProperties(_ref, _excluded);

    if (!frames || !frames.length) {
      return fillInfo(rest);
    }

    for (var i = 0; i < frames.length - 1; i += 1) {
      var startFrame = frames[i];
      var endFrame = frames[i + 1]; // Getting motion

      if (startFrame.frame <= frameRef.current && frameRef.current < endFrame.frame) {
        var startInfo = fillInfo(startFrame, {
          frames: frames.slice(0, i)
        });
        var endInfo = fillInfo(endFrame, {
          frames: frames.slice(0, i + 1)
        });
        var ptg = (frameRef.current - startFrame.frame) / (endFrame.frame - startFrame.frame);
        var cubic = startFrame.cubic;
        return {
          x: getTransitionValue(startInfo.x, endInfo.x, ptg, cubic),
          y: getTransitionValue(startInfo.y, endInfo.y, ptg, cubic),
          rotate: getTransitionValue(startInfo.rotate, endInfo.rotate, ptg, cubic),
          scaleX: getTransitionValue(startInfo.scaleX, endInfo.scaleX, ptg, cubic),
          scaleY: getTransitionValue(startInfo.scaleY, endInfo.scaleY, ptg, cubic),
          originX: getTransitionValue(startInfo.originX, endInfo.originX, ptg, cubic),
          originY: getTransitionValue(startInfo.originY, endInfo.originY, ptg, cubic),
          opacity: getTransitionValue(startInfo.opacity, endInfo.opacity, ptg, cubic),
          theme: endInfo.theme || startInfo.theme
        };
      }
    }

    return fillInfo(frames[frames.length - 1], {
      frames: frames.slice(0, -1)
    });
  }

  function getFramerInfo() {
    return {
      play: triggerRef.current,
      frame: frameRef.current
    };
  }

  React.useEffect(function () {
    // Default to start motion
    if (!initRef.current && configRef.current.defaultPlay !== false) {
      triggerMotion(true);
      initRef.current = true;
    } // Clean up


    return cancelMotion;
  }, []);
  return {
    frame: frameRef.current,
    triggerMotion: triggerMotion,
    getFrameInfo: getFrameInfo,
    getFramerInfo: getFramerInfo,
    setFrame: setFrame
  };
}